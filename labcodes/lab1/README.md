# lab1训练了哪些技能

## 软硬件如何交互

初学计算机的时候，对于软硬件如何交互完全不理解，觉得特别神奇。当时最疑惑的问题是，加电以后电脑如何运行起来，看了网络上关于bootstrap的科普文之后，知道了电脑加电后做了哪些工作。但接着又开始疑惑，我知道了电脑加电后会去做哪些工作，可是电脑怎么知道自己要去做哪些工作，毕竟加电前可以认为电脑是一块铁疙瘩，什么都不知道。后来我也大概琢磨明白了，加电后一股电流涌入相关电子器件，电子器件中的相关电路门会将电流区分为逻辑上的0或者1，到底怎么来表示逻辑上的0或者1，这是硬件电路的事情，让一个稳定的电流（就是电源的输出，没有0或者1的区别）输出变成一串01组成的数据，这是由物理电路设定好的。

为了搞清楚这个我折腾了很久，这就是其他专业想转计算机但没有系统学习走的弯路啊。要是早学了电路相关的知识就好了，唉。

搞明白了电脑是怎么由一个铁疙瘩启动起来之后，就可以讨论软硬件是如何交互的了。我觉得软硬件交互的结合面上，核心是硬件，硬件提供了什么接口，软件就用什么接口。比如CPU的硬件，规定了CPU能接收和处理的合法指令集，也就是机器指令是什么，汇编翻译器根据这个指令集中汇编代码与机器代码的对应关系将汇编翻译成机器代码，机器代码在硬件中又转化为电流在电路中的运行，最终输出一串电流给另外一个硬件。所以为什么有些功能即可以直接用硬件实现，也可以用软件实现呢？就是说既然所有的指令操作最终都是转化为物理介质的一些变化，比如电流，比如磁盘的磁性变化，那么当然可以用硬件直接去产生需要的电流，而不经过软件去指示。这样的功能有不少，比如后面的物理内存与逻辑内存的转化，如果你一定说要用软件实现，也OK的，但是因为这是一个使用非常频繁的功能，都用软件来实现会很慢，所以直接做一个电路，就要快一点。

在lab1的代码中，大量出现了outb和inb指令，实际上就是指导CPU向总线的相关端口写入电流，之后硬件处理完毕后CPU再读取电流，电流会被解释成相关的值，这就是软硬件的结合。说到操作系统驱动硬件，主要工作是将上层应用发过来的要求转换为合适的电流，再将硬件返回的电流转化为对于上层应用有意义、可识别的值罢了。

在lab1中这一点体现的最鲜明的是**键盘驱动**（/kern/driver/console.c/kbd_init函数），很明显地反映这个翻译与转换的过程，值得认真学习。

如果对代码中软硬件交互部分有什么不理解的地方，最好的方式是去查相关的硬件接口，搞清楚这段代码想要驱动的是什么硬件，阅读硬件规定的合法输入电流是什么，输出的电流又代表什么含义，一般来说，接口都有工业标准，阅读相关工业标准也可以。（**devwiki**是权威）

这个供学习的ucore版本驱动的硬件都是古董级的硬件了，虽然在实际应用中已经因为各种原因被淘汰，但作为学习资料，好在早期的硬件比较简单，更容易理解。

## 本章阅读顺序（ucore启动做了哪些工作）

1. boot文件夹

   具体功能见boot文件夹下面的README.md。完成boot之后，就将kernel文件加载到扇区中去，再跳转到elf文件的入口地址处执行。

   其实不是elf格式也没问题，只要你在bootmain里能很好地定义入口地址就可以。

2. kern文件夹中的init/init.c文件

   kern_init()负责操作系统的初始化，包括以下几个步骤：

   + 初始化未初始化的全局变量

   + 初始化终端

     + 初始化显示器
     + 初始化串行接口
     + 初始化键盘

   + 打印启动消息和内核信息

   + 初始化段空间。

     要注意的是段空间在boot时已经初始化过一次，但是系统有自己的段分配方案，因此重新初始化一次，用以支持用户态向内核态的陷入，引入了TSS段。

   + 为中断功能做准备

     即设定IDT，将IDT起始地址装载到寄存器中等。

   + 初始化时钟。

   + 使能中断。

   因为lab1阶段，主要是让系统能启动起来，能接受中断即可，不需要系统能做更多的工作，因此最后以一个while(true)作为结束，此时按键盘就应该产生相应的在中断，从而在屏幕中输出某些数值。

3. tools/kernel.ld

   这是链接器使用的文件，定义了很多重要的变量名，指定了elf文件入口。（尴尬的是这一段最上面的注释是for JOS kernel，也就是说ucore这段代码是抄JOS的咯？哈哈~who cares）

   在kernel.ld中指定了ucore的elf文件的内存布局，除常规字段外，有这么几个重要的字段需要关注。

   + ENTRY(kern_init)，意思是将入口地址设为kern_init()，这样做以后编译时elf头会将相应数据结构的程序入口地址写为这个函数的地址。也就是bootmain()函数中调用的那个Entry
   + PROVIDE(edata = .) 和 PROVIDE(end = .)，意思是将当前位置的地址赋予给edata/end变量。这两个变量在kern_init()中都用extern关键字引入使用了。需要注意的是这两个数据直接框定了所有的全局变量，而在kern_init()中，将这两个地址之间的内存空间全部写0了，相当于一次初始化。
   + .stbstr。这是GCC在编译时留下的debug段（gcc -g编译时会生成，一般用于GBD）。这里生成了两个重要的变量，\_\_STABSTR_BEGIN\_\_和\_\_STABSTR_END\_\_，后面追踪函数调用栈时会用到。

4. kern/trap/vector.S

   初始化了中断处理程序，提供了重要的变量\_\_vectors[]，这个变量里放着各个中断处理程序的地址。idt需要据此设置中断向量表。

##一些重要的调用流程

1. cprintf()函数调用流程
  $$
  cprintf()-vcprintf()-vprintfmt() - cputch()   - cons\_putc() -
  \begin{cases}
  -> lpt\_putc()    -lpt\_putc\_sub()\\
  -> cga\_putc()\\
  -> serial\_putc() - serial\_putc\_sub()\\
  \end{cases}
  $$
  追踪到最后，可见实际上格式化之后，还是一个字符一个字符输出到显示器的，ucore里实现了同时向并行、串行和CGA口输出三种输出，这个思路倒是挺有意思。

2. grade_backtrace()函数调用流程
   $$
   init\_kern() - grade\_backtrace\{0,1,2\}() - mon\_backtrace() - print\_stackfram()
   $$


   理解这个函数最重要的是理解函数调用中压栈的相关约定，所谓的函数调用惯例。同时还要理解进程文件是如何装载的，即如何从硬盘上读取到内存中去的，内存装载位置的相关约定；GCC在生成elf文件时把debug数据放到哪里去了，实际上mom_backtrace()正是依靠这里面的debug段来实现函数的位置追踪的。

## 需要着重理解的几个过程

+ 键盘是如何驱动起来的
+ 中断是如何使能的，如何工作的。

## lab1的四个实验是什么

1. 追踪grade\_backtrace()函数调用栈，并打印出来。代码在kern/debug/kdebug.c

   这个要完成实验很简单，只要了解压栈规定就OK，何况其他工作源代码都已经给做完了。但在这个函数调用栈里寻找源代码是如何追踪当前运行代码是哪个函数的，这个倒有点意思。

2. 初始化idt，并将idt的地址装入寄存器。代码在kernel/trap/trap.c

   这个实验重要的目的是促使掌握中断是怎么工作的。

   中断分为硬件中断和软件中断，软件中断有我们经常所说的异常、系统调用等，这一般是由特殊的代码引起的，是同步的行为。如系统调用，调用后就直接陷入系统内核进行处理了，处理完之后再返回调用处继续工作。这和异步的硬件中断其实相差很大。在这里我们讨论硬件中断的处理。

   所谓硬件中断，一般是因为IO设备引起的，比如键盘、鼠标、网络设备等。早期的计算机（就是ucore这段代码试图驱动的计算机硬件）硬件，比如8259，在设计上区分了master和slavePIC，其中masterPIC下最多可以挂载8个slavePIC，也就是最多可以扩展到64个中断线，这就是ICW3（IO控制器初始化命令3）做的事。

   一般挂载一个slave到master的line2，这就总共有了16条硬件中断line，因为line8到15映射到line2，所以实际可用的是15条中断线，分别对应15种硬件中断，比如时钟中断、串口、并口、键盘等，其中中断线0-7由PIC1控制，8-15由PIC2控制。

   当相关硬件准备好之后，就会将相应的中断线置为活动。此时所有的中断数据首先经过一个中断屏蔽器，如果被屏蔽了，就over，如果没有屏蔽，再进入中断排队器，一个一个来嘛。这个排队有一些不同的实现方法，基本是引脚数字越小越优先这个样子。

   排队之后把这个最终的中断向量放到中断控制器的IO端口，也就是0x20或者0xA0，之后把引发信号放到处理器的INTR引脚，之后就等着CPU来临幸。CPU检查到INTR引脚有信号，就会来检查相关端口，读出中断向量。[CSDN:intel CPU的中断](https://blog.csdn.net/baidu_24256693/article/details/64920137)

   这有一篇中文的，辅助理解。

   ![](http://images.cnitblog.com/blog2015/687284/201504/031610264356459.jpg)

   读出中断向量以后去干什么呢？就是去读IDT，把相关中断处理程序的地址读出来好运行。IDT的起始地址存储于CPU的IDTR中，与GDTR一样，这是个48位的寄存器（32位基地址加16位表大小）。

   中断处理程序和IDT都可以放到内存中的任何区域。ucore中的中断处理进程都比较简单，就是把压栈一个0，然后压栈一个中断向量号，接着就调用__alltraps()（定义于trap/trapentry.S中）进行寄存器保存操作，保存完毕后再调用trap()，trap()调用trap_dispatch()来实际处理中断。

3. 根据要求处理时钟中断。这里的处理方式是时钟中断加一，每到100输出一次。代码在kernel/trap/trap.c

   实在没什么好说。

4. 完成用户态和内核态的切换。代码在/kern/init/init.c

   这个实际上也是用了系统调用，IDT的第120项就是从用户态陷入内核态，第121是从内核态跳到用户态。